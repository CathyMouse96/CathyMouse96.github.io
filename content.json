{"pages":[],"posts":[{"title":"Algo final review - Approximation algorithms","text":"By CMouse, May 2019. Disclaimer: Some sentences are taken from DPV textbook. OverviewHierarchy: No finite approximation ratio possible (e.g. General TSP). Approximation ratio about $logn$ (e.g. Set Cover). Approximation ratio is possible, but there are limits to how small it can be (e.g. Vertex Cover, $k$-Cluster, TSP with triangle inequality). Approximability has no limits (e.g. Knapsack). ExamplesSet CoverAlgorithm: Pick the set $S_i$ with the largest number of uncovered elements. Repeat until all elements of $E$ are covered. Approximation ratio: $\\alpha_A=logn$, where $n$ is the number of elements in $E$. Reasoning: Let $n_t$ be the number of elements uncovered after $t$ iterations. Suppose the optimal number of sets is $k$, the set with the largest number of uncovered elements will cover at least $n_t/k$ of them. Therefore, the greedy strategy will ensure that $n_{t+1}\\leq n_t - \\frac{n_t}{k}=n_k(1-\\frac{1}{k})$, which by repeated application implies $n_t\\leq n_0(1-\\frac{1}{k})^t$. Since $1-x\\leq e^{-x}$, with equality if and only if $x=0$, $n_t&lt; n_0 e^{-t/k}=n e^{-t/k}$. When $t=klnn$, $n_t$ is strictly less than $1$, so all the elements are covered. Therefore, the greedy solution takes at most $klnn$ sets. Vertex CoverAlgorithm: Find a maximal matching. Add both endpoints of the edges in the matching to the vertex cover. Approximation ratio: $\\alpha_A = 2$. Reasoning: Optimal vertex cover has size at least that of maximal matching. Adding both endpoints of all the edges in the matching is guaranteed to form a vertex cover. Matching: a subset of edges that have no vertices in common. Maximal matching: a matching that cannot have any more edges added to it; can be generated by repeatedly adding edges until no longer possible. Maximum matching: a matching that contains the largest possible number of edges. k-ClusterAlgorithm: Randomly pick first cluster center $\\mu_1$. Repeatedly pick clusters centers $\\mu_2, \\mu_3, …, \\mu_k$ such that $\\mu_i$ is always the farthest possible point away from $\\mu_1, …, \\mu_{i-1}$. Approximation ratio: $\\alpha_A=2$. Reasoning: If pick another cluster center $\\mu_{k+1}$ which has distance $r$ to previous cluster centers, can show that optimal cluster diameter is at least $r$, and current cluster diameter is at most $2r$. TSP with triangle inequalityAlgorithm: Approximation ratio: Reasoning: KnapsackApproximation ratio: $\\alpha_A=1- \\epsilon$, where $\\epsilon$ can be arbitrarily small. Additional ExercisesDPV 9.4 Independent SetAlgorithm: Choose any node and add it to the independent set. Delete the node and its neighbors from the graph. Repeat until graph is empty. Approximation ratio: $\\alpha_A=1/(d+1)$, where $d$ is the maximum degree of the nodes in the graph. Reasoning: The optimal independent set will have at most $|V|$ nodes. The approximate independent set will have at least $|V|/(d+1)$ nodes, because for every node we add, we delete at most $(d+1)$ nodes, i.e. for every $(d+1)$ nodes in the graph, there is at least one node in the independent set.","link":"/2019/05/13/Algo-final-review-Approximation-algorithms/"},{"title":"Algo final review - NP-complete problems","text":"By CMouse, May 2019. Disclaimer: Some sentences are taken from DPV textbook. ProblemsSATGiven any instance $(I)$, which is a Boolean formula in conjunctive normal form, find an assignment that satisfies each clause. 3SATGiven any instance $(I)$, which is a Boolean formula in conjunctive normal form and each clause contains at most three literals, find an assignment that satisfies each clause. Special case of SAT. Rudrata PathGiven any instance $(G=(V, E))$, where $G$ is undirected, find a path that visits each vertex exactly once. In contrast, the Euler Path problem (traverse each edge exactly once) can be solved in polynomial time. Rudrata CycleGiven any instance $(G=(V, E))$, where $G$ is undirected, find a cycle that visits each vertex exactly once. Traveling Salesman Problem (TSP)Given any instance $(d, b)$, where $d$ is distance matrix and $b$ is budget, find a cycle that passes through each vertex exactly once, of total cost $b$ or less. TSP is essentially min weight Rudrata Cycle. Longest PathGiven any instance $(G=(V, E, w), s, t, g)$, where edge weights $w$ are nonnegative, find a simple (no repeated vertices) path from $s$ to $t$ with total weight at least $g$. 3D MatchingGiven any instance $(m \\text{ boys}, m \\text{ girls}, m \\text{ pets}, n \\text{ triples})$, find $m$ disjoint triples. Special case of Set Cover. KnapsackGiven any instance $(w_1, …, w_n, v_1, …, v_n, W, g)$, where $w_i$ and $v_i$ are integers, find a set of items whose total weight is at most $W$ and whose total value is at least $g$. Subset SumGiven any instance $(w_1, …, w_n, W)$, where $w_i$ is an integer, find a subset of the given integers that adds up to exactly $W$. Special case of Knapsack. Independent SetGiven any instance $(G=(V, E), g)$, find $g$ vertices that are independent, that is, no two of which have an edge between them. Vertex CoverGiven any instance $(G=(V, E), b)$, find $b$ vertices that cover (touch) every edge. Special case of Set Cover. Set CoverGiven any instance $(E, S_1, …, S_m, b)$, find $b$ subsets such that their union is $E$. CliqueGiven any instance $(G=(V, E), g)$, find $g$ vertices such that all possible edges between them are present. Integer Linear Programming (ILP)Given any instance $(A, b)$, find a nonnegative integer vector $x$ satisfying the inequalities $Ax\\leq b$. Zero-One Equations (ZOE)Given any instance $(A)$, where $A$ is an $m$ x $n$ matrix with 0 - 1 entries, find a 0 - 1 vector $x$ such that the $m$ equations $Ax=1$. Balanced CutGiven any instance $(G=(V, E), b)$, partition the vertices into two sets $S$ and $T$ such that $|S|, |T|\\geq |V|/3$ and such that there are at most $b$ edges between $S$ and $T$. ReductionsRudrata (s, t)-Path -&gt; Rudrata CycleThe reduction maps an instance $(G=(V, E), s, t)$ of Rudrata $(s, t)$-path to an instance $(G’=(V, E))$ of Rudrata Cycle as follows: add a dummy node $a$, and add edges $(t, a)$ and $(a, s)$. To recover a solution of Rudrata $(s, t)$-path, we simply remove the edges $(t, a)$ and $(a, s)$ from the Rudrata Cycle. Rudrata Cycle -&gt; TSPThe reduction maps an instance $(G’=(V, E))$ of Rudrata Cycle to an instance $(d, b)$ of TSP as follows: for each pair of vertices $(i, j)$, $d_{ij}=1$ if there is an edge between them, and $1+\\alpha$ (where $\\alpha &gt; 0$) otherwise, and $b=|V|$. To recover a solution of Rudrata Cycle, we simply return the solution of TSP. Independent Set -&gt; Vertex CoverThe reduction maps an instance $(G=(V, E), g)$ of Independent Set to an instance $(G’=(V’, E’), b)$ of Vertex Cover as follows: $G’$ is simply $G$, and $b=|V|-g$. To recover a solution of Independent Set, we simply return the vertices that are not in the Vertex Cover. Works the other way too. Independent Set -&gt; CliqueThe reduction maps an instance $(G=(V, E), g)$ of Independent Set to an instance $(G’=(V’, E’), g’)$ of Clique as follows: $G’$ is the complement of $G$, and $g’=g$. To recover a solution of Independent Set, we simply return the vertices that are in the Clique. Works the other way too. 3D Matching -&gt; ZOEThe reduction maps an instance $(m \\text{ boys}, m \\text{ girls}, m \\text{ pets}, n \\text{ triples})$ of 3D Matching to an instance $(A)$ of ZOE as follows: $A$ has $3m$ rows and $n$ columns, and the $(i, j)$th element is $1$ if the $i$th boy/girl/pet is in the $j$th triple, and $0$ otherwise. To recover a solution of 3D Matching, we select the triples whose corresponding variables are assigned to be $1$. ZOE -&gt; ILPThe reduction maps an instance $(A)$ of ZOE to an instance $(A’, b)$ of ILP as follows: rewrite every equation $ax=1$ as two inequalities $ax\\leq 1$ and $-ax\\leq -1$, and for each variable $x_i$, add two constraints $x_i\\leq 1$ and $-x_i\\leq 0$. To recover a solution of ZOE, we simply return the solution of ILP. ZOE -&gt; Subset SumThe reduction maps an instance $(A)$ of ZOE to an instance $(w_1, …, w_n, W)$ of Subset Sum as follows: $w_i$ is the integer encoded by the $i$th column in $(n+1)$-ary, and $W=(n+1)^m-1$, where $m$ is the number of rows and $n$ is the number of columns. To recover a solution of ZOE, we assign the variables that are in the subset to be $1$ and the others to be $0$. ZOE -&gt; Rudrata Cycle3SAT -&gt; Independent SetThe reduction maps an instance $(I)$ of 3SAT to an instance $(G=(V, E), g)$ of Independent Set as follows: $V$ consists of all the variables and their negations, and there are edges between literals in the same clause, as well as variables and their negations, and $g$ is equal to the number of clauses. To recover an assignment of 3SAT, we assign true to the variables that are in the independent set, false to the variables whose negations are in the independent set, and either true or false otherwise. SAT -&gt; 3SATThe reduction maps an instance $(I)$ of SAT to an instance $(I’)$ of 3SAT as follows: for any clause that has more than three literals in $I$, say $(a_1\\vee a_2 \\vee…\\vee a_n)$, change it to $(a_1\\vee a_2\\vee y_1)\\wedge (\\bar{y_1}\\vee a_3\\vee y_2)\\wedge … \\wedge (\\bar{y_{n-3}}\\vee a_{n-1}\\vee a_n)$. To recover an assignment of SAT, we simply return the assignment of 3SAT without the added variables. 3SAT -&gt; Constrained 3SATConstrained 3SAT: No variable appears in more than three clauses. The reduction maps an instance $(I)$ of SAT to an instance $(I’)$ of 3SAT as follows: for any variable $x$ that appears in more than three clauses, replace its first appearance with $x_1$, second appearance with $x_2$, …, $k$th appearance with $x_k$ and add the clauses $(x_1\\vee \\bar{x_2})\\wedge (x_2\\vee \\bar{x_3})\\wedge … \\wedge (x_n\\vee \\bar{x_1})$. To recover an assignment of 3SAT, we simply return the assignment of Constrained 3SAT with the added variables mapped back to the original variables. 3SAT -&gt; 3D MatchingAny problem in NP -&gt; SATAdditional ExercisesDPV 8.15 Maximum Common SubgraphIdea: prove by generalization (Clique -&gt; Maximum Common Subgraph). The reduction maps an instance $(G=(V, E), g)$ of Clique to an instance $(G_1=(V_1, E_1), G_2=(V_2, E_2), b)$ as follows: $G_1$ is simply $G$, $G_2$ is a complete graph with $g$ nodes, i.e. $K_g$, and $b=g$. To recover a solution of Clique, return $V_1-V_1’$.","link":"/2019/05/12/Algo-final-review-NP-complete-problems/"},{"title":"Google CTF Beginners Quest Notes","text":"This is my first attempt at CTF and I’m stumbling along with the help of walkthroughs on Google :-) I’m posting my notes as I learn. SPOILERS ALERT! Do not keep reading if you want to solve the problems on your own. Link to Google CTF. LetterThis is what the first challenge looks like. The username and password are blacked out, but we can still select the text and copy and paste! The flag is CTF{ICanReadDis}. OCR IS COOL!The attachment is a screenshot like this. The text is gibberish, but we notice something suspicious: VMY{vtxltkvbiaxkbltlnulmbmnmbhgvbiaxk}. The format is suspiciously similar to our flag format: CTF{…}. So lets say V stands for C, M stands for T and Y stands for F. Since this is an email, we can guess that it begins with “Dear xxx”. So we further guess that W stands for D, X stands for E, T stands for A and K stands for R. When we write it out, we find that it actually is the Caesar cipher. Here, every letter x is substituted by x + 19. We recover the original flag, which is CTF{caesarcipherisasubstitutioncipher}. (In hindsight, the hint “Caesar once said, don’t stab me…” makes sense!) Security by obscurityFloppyI was soooo proud when I solved this, even though it is pretty easy, because it is the first challenge I ever solved on my own! The attachment is what seems like an icon - but isn’t. In fact, it contains two zip files. When we run binwalk on the icon, we get this: Yup, not an innocent image! The flag is CTF{qeY80sU6Ktko8BJW}, as we can see. Floppy2JS SAFESolved 3/25/2019. Soooo proud again! Though it did take me an ENORMOUS amount of time. Hope I’ll get faster with practice. So this time we have a safe like this and its corresponding html file. When we enter the password, open_safe() is called, which in turn calls x(password) to check if the password is valid. Let’s take a look at x(password). FirmwareSolved 4/12/2019. The attachment is a large file called challenge.ext4. It is likely filesystem data and we should mount it. Originally this file was in a shared folder between my host and vm, under /media. When I tried to mount it, I kept getting this error: mount: /mnt/challenge: can't read superblock on /dev/loop23. Moving the file to ~/Documents and then mounting it works. I don’t know why. This cost me some time. The rest is pretty straightforward: Mount the filesystem (sudo mount ~/Documents/challenge.ext4 /mnt/challenge/), switch to the mount point (cd /mnt/challenge/) and look at the files (ls -al). We see a file .mediapc_backdoor_password.gz. Extracting it gives us .mediapc_backdoor_password, which is a text file storing the flag. GatekeeperSolved 4/12/2019. The attachment is an ELF executable. Lets try executing the file: Executing with some random username and password: Lets see if the username and password are stored somewhere in the code! Use strings gatekeeper: Among the output we have these. Jackpot? Lets try. Not quite. But at least we’ve got the username! It’s expected - the stored password would likely be some variant of the actual password, like a hash. But the transformation here should be much simpler than a hash. It’s time to look at the code. We can use objdump -d gatekeeper to obtain the assembly code of the object file. I won’t go into the details of analysing the assembly code, but we can find that the input password is REVERSED before being compared to the stored password. So we simply have to reverse the stored password, which gives us “I_g0T_m4d_sk1lLz”. Well, I’m sure you do :-) MEDIA_DBSolved 4/12/2019. MoarSolved 4/12/2019. Yeeeeeesssss. I’ve finally got this one. Been stuck on it for so long. So we connect to a network service with nc moar.ctfcompetition.com 1337. It apparently serves the man page of the socat command. I had no idea how to approach this and have actually tried to read the man page. (The hint did say “As the old saying goes, everything you need is in the manual.”) However, it wasn’t socat‘s man page I should be reading. If we press h, we enter the help page of less, which the service is using to display its pages. I’ve never scrolled down far enough before, but today I did, and I found this: Now this looks destructive. Lets do !ls. We find out we are in /. Then we do !ls /home. We find a directory called moar. Lets do !ls /home/moar. We find a shell script called disable_dmz.sh. We execute the script and find the flag:","link":"/2019/03/24/Google-CTF-Beginners-Quest-Notes/"},{"title":"LRU Cache","text":"This is my solution to LeetCode’s LRU Cache problem. It is written in Python 3. In this problem, we are asked to implement an LRU cache that supports get(key) and put(key, value) in O(1) time. IntuitionWe can easily achieve O(1) time for get(key) if we use a hash table for the cache. However, we need to maintain the LRU status, or in other words, the order in which cache entries were accessed. If we use an array, time complexity for the operations will become O(n). So we think about using a linked list. For each key in the cache, along with its value, we store a prev pointer and a next pointer. The prev pointer points to the entry that was accessed immediately before this entry was accessed. The next pointer points to the entry that was accessed immediately after this entry was accessed. We also maintain two variables lru and mru: the key that was accessed least recently and the key that was accessed most recently, respectively. The cache looks like this: get(key) operationIf key does not exist in our cache, we return -1.If key already is the most recently accessed key (mru == key and cache[key].next == None), we do not need to make any changes to the LRU status. We simply return its value.Otherwise, if key originally was the least recently accessed key (lru == key and cache[key].prev == None), cache[key].next now becomes the least recently accessed key, and key now becomes the most recently accessed key.Otherwise, we remove key from its original spot and make it the most recently accessed key.The code is as follows:1234567891011121314151617181920212223242526272829def get(self, key): \"\"\" :type key: int :rtype: int \"\"\" if key not in self.cache: return -1 # Update LRU status value, lruprev, lrunext = self.cache[key] if not lrunext: # Already most recently used pass elif not lruprev: # Originally least recently used # next becomes lru self.cache[lrunext][1] = None self.lru = lrunext # key becomes mru self.cache[self.mru][2] = key self.cache[key][1] = self.mru self.cache[key][2] = None self.mru = key else: self.cache[lruprev][2] = lrunext self.cache[lrunext][1] = lruprev # key becomes mru self.cache[self.mru][2] = key self.cache[key][1] = self.mru self.cache[key][2] = None self.mru = key return value","link":"/2018/11/14/LRU-Cache/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/11/14/hello-world/"}],"tags":[{"name":"algorithms","slug":"algorithms","link":"/tags/algorithms/"},{"name":"computer theory","slug":"computer-theory","link":"/tags/computer-theory/"},{"name":"Google CTF","slug":"Google-CTF","link":"/tags/Google-CTF/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"Python 3","slug":"Python-3","link":"/tags/Python-3/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"IDS","slug":"IDS","link":"/categories/IDS/"}]}