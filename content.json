{"pages":[],"posts":[{"title":"Active Authentication on macOS: Part 1","text":"For our second project for COMS E6185 Intrusion Detection Systems, we are implementing an active authentication system based on user behavior. The process can be divided into four parts: collecting data, constructing a model, training the model and testing the model. In this part, we collect user behavior data by recording system-level events, such as process creation and deletion and file changes [1]. We make use of the audit subsystem that comes with macOS [2]. The audit utility is started by default at system startup. Configuring the audit utilityWe can configure the audit utility by editing /etc/security/audit_control. The default configuration is as follows:1234567891011121314## $P4: //depot/projects/trustedbsd/openbsm/etc/audit_control#8 $#dir:/var/auditflags:lo,aaminfree:5naflags:lo,aapolicy:cnt,argvfilesz:2Mexpire-after:10Msuperuser-set-sflags-mask:has_authenticated,has_console_accesssuperuser-clear-sflags-mask:has_authenticated,has_console_accessmember-set-sflags-mask:member-clear-sflags-mask:has_authenticated You can find a detailed explanation of the parameters at man audit_control. Here, we are mainly concerned with the dir, flags and naflags parameters. The dir parameter specifies where the audit records are logged to. You can specify it to anywhere you like. The flags parameter specifies which classes of audit events will be audited that can be tied back to a specific user. The naflags parameter stands for nonattributable flags and specifies which classes of audit events will be audited that cannot be tied back to a specific user. [3] For our purposes, we set both to pc,nt,lo,aa. You can find the classes of audit events in /etc/security/audit_class:1234567891011121314151617181920212223## $P4: //depot/projects/trustedbsd/openbsm/etc/audit_class#6 $#0x00000000:no:invalid class0x00000001:fr:file read0x00000002:fw:file write0x00000004:fa:file attribute access0x00000008:fm:file attribute modify0x00000010:fc:file create0x00000020:fd:file delete0x00000040:cl:file close0x00000080:pc:process0x00000100:nt:network0x00000200:ip:ipc0x00000400:na:non attributable0x00000800:ad:administrative0x00001000:lo:login_logout0x00002000:aa:authentication and authorization0x00004000:ap:application0x20000000:io:ioctl0x40000000:ex:exec0x80000000:ot:miscellaneous0xffffffff:all:all flags set Note that setting flags and naflags to all will take up a lot of logging space in a very short time so be careful!!! After we modify the audit control file, we can run audit -s to restart the audit system with the new configuration. Editing the configuration file and running this command should require root privileges. Voilà! You should now see a new log file appearing in your specified directory. The log files are in a special binary format so you cannot view them directly, but you can view their contents with the praudit command. Running praudit /dev/auditpipe should give you something like this:12345678910header,79,11,recvfrom(2),0,Sun Nov 25 17:11:53 2018, + 743 msecargument,1,0x36,fdsubject,-1,_mdnsresponder,_mdnsresponder,_mdnsresponder,_mdnsresponder,148,100000,0,0.0.0.0return,success,28trailer,79header,79,11,recvmsg(2),0,Sun Nov 25 17:11:53 2018, + 743 msecargument,1,0x36,fdsubject,-1,_mdnsresponder,_mdnsresponder,_mdnsresponder,_mdnsresponder,148,100000,0,0.0.0.0return,success,38trailer,79 Each record is consisted of tokens. For example, the two records above have the following five tokens: header, argument, subject, return and trailer. Records for different events will have different tokens and detailed information can be found at man audit.log. [4] Reading the log filesReferences:[1] Jonathan Voris, Yingbo Song, Malek Ben Salem, Shlomo Hershkop, Salvatore Stolfo, Active authentication using file system decoys and user behavior modeling: results of a large scale study, Computers &amp; Security, 2018, ISSN 0167-4048.[2] Common Criteria Configuration and Administration Guide - Apple, https://images.apple.com/support/security/commoncriteria/CommonCriteriaAdminGuide.pdf[3] OpenBSM auditing on Mac OS X, https://derflounder.wordpress.com/2012/01/30/openbsm-auditing-on-mac-os-x/[4] Reading Mac BSM Audit Logs, https://crucialsecurity.wordpress.com/2012/05/17/reading-mac-bsm-audit-logs-2/","link":"/2018/11/25/Active-Authentication-on-macOS-Part-1/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/11/14/hello-world/"},{"title":"LRU Cache","text":"This is my solution to LeetCode’s LRU Cache problem. It is written in Python 3. In this problem, we are asked to implement an LRU cache that supports get(key) and put(key, value) in O(1) time. IntuitionWe can easily achieve O(1) time for get(key) if we use a hash table for the cache. However, we need to maintain the LRU status, or in other words, the order in which cache entries were accessed. If we do so using an array, time complexity for the operations will become O(n). So we think about using a linked list. For each key in the cache, along with its value, we store a prev pointer and a next pointer. The prev pointer points to the entry that was accessed immediately before this entry was accessed. The next pointer points to the entry that was accessed immediately after this entry was accessed. We also maintain two variables lru and mru: the key that was accessed least recently and the key that was accessed most recently, respectively. The cache looks like this: get(key) operationIf key does not exist in our cache, we return -1.If key already is the most recently accessed key (mru == key and cache[key].next == None), we do not need to make any changes to the LRU status. We simply return its value.Otherwise, if key originally was the least recently accessed key (lru == key and cache[key].prev == None), cache[key].next now becomes the least recently accessed key, and key now becomes the most recently accessed key.Otherwise, we remove key from its original spot and make it the most recently accessed key.The code is as follows:1234567891011121314151617181920212223242526272829def get(self, key): \"\"\" :type key: int :rtype: int \"\"\" if key not in self.cache: return -1 # Update LRU status value, lruprev, lrunext = self.cache[key] if not lrunext: # Already most recently used pass elif not lruprev: # Originally least recently used # next becomes lru self.cache[lrunext][1] = None self.lru = lrunext # key becomes mru self.cache[self.mru][2] = key self.cache[key][1] = self.mru self.cache[key][2] = None self.mru = key else: self.cache[lruprev][2] = lrunext self.cache[lrunext][1] = lruprev # key becomes mru self.cache[self.mru][2] = key self.cache[key][1] = self.mru self.cache[key][2] = None self.mru = key return value","link":"/2018/11/14/LRU-Cache/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"Python 3","slug":"Python-3","link":"/tags/Python-3/"}],"categories":[{"name":"IDS","slug":"IDS","link":"/categories/IDS/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}