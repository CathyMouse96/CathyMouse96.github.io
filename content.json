{"pages":[],"posts":[{"title":"Google CTF Beginners Quest Notes","text":"This is my first attempt at CTF and I’m stumbling along with the help of walkthroughs on Google :-) I’m posting my notes as I learn. SPOILERS ALERT! Do not keep reading if you want to solve the problems on your own. Link to Google CTF. LetterThis is what the first challenge looks like. The username and password are blacked out, but we can still select the text and copy and paste! The flag is CTF{ICanReadDis}. OCR IS COOL!The attachment is a screenshot like this. The text is gibberish, but we notice something suspicious: VMY{vtxltkvbiaxkbltlnulmbmnmbhgvbiaxk}. The format is suspiciously similar to our flag format: CTF{…}. So lets say V stands for C, M stands for T and Y stands for F. Since this is an email, we can guess that it begins with “Dear xxx”. So we further guess that W stands for D, X stands for E, T stands for A and K stands for R. When we write it out, we find that it actually is the Caesar cipher. Here, every letter x is substituted by x + 19. We recover the original flag, which is CTF{caesarcipherisasubstitutioncipher}. (In hindsight, the hint “Caesar once said, don’t stab me…” makes sense!) Security by obscurityFloppyI was soooo proud when I solved this, even though it is pretty easy, because it is the first challenge I ever solved on my own! The attachment is what seems like an icon - but isn’t. In fact, it contains two zip files. When we run binwalk on the icon, we get this: Yup, not an innocent image! The flag is CTF{qeY80sU6Ktko8BJW}, as we can see. Floppy2JS SAFESolved 3/25/2019. Soooo proud again! Though it did take me an ENORMOUS amount of time. Hope I’ll get faster with practice. So this time we have a safe like this and its corresponding html file. When we enter the password, open_safe() is called, which in turn calls x(password) to check if the password is valid. Let’s take a look at x(password). FirmwareSolved 4/12/2019. The attachment is a large file called challenge.ext4. It is likely filesystem data and we should mount it. Originally this file was in a shared folder between my host and vm, under /media. When I tried to mount it, I kept getting this error: mount: /mnt/challenge: can't read superblock on /dev/loop23. Moving the file to ~/Documents and then mounting it works. I don’t know why. This cost me some time. The rest is pretty straightforward: Mount the filesystem (sudo mount ~/Documents/challenge.ext4 /mnt/challenge/), switch to the mount point (cd /mnt/challenge/) and look at the files (ls -al). We see a file .mediapc_backdoor_password.gz. Extracting it gives us .mediapc_backdoor_password, which is a text file storing the flag. GatekeeperSolved 4/12/2019. The attachment is an ELF executable. Lets try executing the file: Executing with some random username and password: Lets see if the username and password are stored somewhere in the code! Use strings gatekeeper: Among the output we have these. Jackpot? Lets try. Not quite. But at least we’ve got the username! It’s expected - the stored password would likely be some variant of the actual password, like a hash. But the transformation here should be much simpler than a hash. It’s time to look at the code. We can use objdump -d gatekeeper to obtain the assembly code of the object file. I won’t go into the details of analysing the assembly code, but we can find that the input password is REVERSED before being compared to the stored password. So we simply have to reverse the stored password, which gives us “I_g0T_m4d_sk1lLz”. Well, I’m sure you do :-) MEDIA_DBSolved 4/12/2019.","link":"/2019/03/24/Google-CTF-Beginners-Quest-Notes/"},{"title":"LRU Cache","text":"This is my solution to LeetCode’s LRU Cache problem. It is written in Python 3. In this problem, we are asked to implement an LRU cache that supports get(key) and put(key, value) in O(1) time. IntuitionWe can easily achieve O(1) time for get(key) if we use a hash table for the cache. However, we need to maintain the LRU status, or in other words, the order in which cache entries were accessed. If we use an array, time complexity for the operations will become O(n). So we think about using a linked list. For each key in the cache, along with its value, we store a prev pointer and a next pointer. The prev pointer points to the entry that was accessed immediately before this entry was accessed. The next pointer points to the entry that was accessed immediately after this entry was accessed. We also maintain two variables lru and mru: the key that was accessed least recently and the key that was accessed most recently, respectively. The cache looks like this: get(key) operationIf key does not exist in our cache, we return -1.If key already is the most recently accessed key (mru == key and cache[key].next == None), we do not need to make any changes to the LRU status. We simply return its value.Otherwise, if key originally was the least recently accessed key (lru == key and cache[key].prev == None), cache[key].next now becomes the least recently accessed key, and key now becomes the most recently accessed key.Otherwise, we remove key from its original spot and make it the most recently accessed key.The code is as follows:1234567891011121314151617181920212223242526272829def get(self, key): \"\"\" :type key: int :rtype: int \"\"\" if key not in self.cache: return -1 # Update LRU status value, lruprev, lrunext = self.cache[key] if not lrunext: # Already most recently used pass elif not lruprev: # Originally least recently used # next becomes lru self.cache[lrunext][1] = None self.lru = lrunext # key becomes mru self.cache[self.mru][2] = key self.cache[key][1] = self.mru self.cache[key][2] = None self.mru = key else: self.cache[lruprev][2] = lrunext self.cache[lrunext][1] = lruprev # key becomes mru self.cache[self.mru][2] = key self.cache[key][1] = self.mru self.cache[key][2] = None self.mru = key return value","link":"/2018/11/14/LRU-Cache/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/11/14/hello-world/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"Google CTF","slug":"Google-CTF","link":"/tags/Google-CTF/"},{"name":"Python 3","slug":"Python-3","link":"/tags/Python-3/"}],"categories":[{"name":"IDS","slug":"IDS","link":"/categories/IDS/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}